import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as p;

void main(List<String> args) async {
  // Locate files
  final scriptDir = p.dirname(Platform.script.toFilePath());
  final repoRoot = p.normalize(p.join(scriptDir, '../..'));
  final dumpFile =
      File(p.join(repoRoot, 'tool/semantics_generator/semantics_dump.json'));
  final outFile =
      File(p.join(repoRoot, 'lib/src/utils/known_widget_semantics.dart'));

  // Check dump file exists
  if (!dumpFile.existsSync()) {
    stderr.writeln('ERROR: semantics_dump.json not found.');
    stderr.writeln('Run the extractor test first:');
    stderr.writeln(
        '  flutter test test/semantics_generator/extract_semantics_test.dart');
    exit(1);
  }

  // Load JSON data
  final json =
      jsonDecode(await dumpFile.readAsString()) as Map<String, dynamic>;

  // ignore: avoid_print
  print('Generating known_widget_semantics.dart...');
  // ignore: avoid_print
  print('Processing ${json.length} widgets');

  // Generate Dart source
  final buffer = StringBuffer()
    ..writeln('// GENERATED CODE - DO NOT MODIFY BY HAND')
    ..writeln('// Generated by tool/semantics_generator/generate_source.dart')
    ..writeln('// From runtime Flutter semantics extraction')
    ..writeln('//')
    ..writeln('// To regenerate: ')
    ..writeln(
        '//   1. flutter test test/semantics_generator/extract_semantics_test.dart')
    ..writeln('//   2. dart tool/semantics_generator/generate_source.dart')
    ..writeln()
    ..writeln("import '../types/semantic_role.dart';")
    ..writeln("import 'widget_semantics_info.dart';")
    ..writeln()
    ..writeln('/// Pre-built semantic information for Flutter built-in widgets')
    ..writeln('class KnownWidgetSemantics {')
    ..writeln('  /// Map of widget names to their semantic information')
    ..writeln('  static const Map<String, WidgetSemanticsInfo> widgets = {');

  // Process each widget
  json.forEach((name, value) {
    final data = value as Map<String, dynamic>;

    // Skip widgets that failed extraction (have error field)
    if (data.containsKey('error')) {
      // ignore: avoid_print
      print('⚠ Skipping $name: ${data['error']}');
      return;
    }

    // Extract flags from runtime semantics
    // Note: label/hint/value fields are ignored as they reflect test data,
    // not widget behavior. We only use semantic flags and actions.
    final isButton = data['isButton'] == true;
    final isImage = data['isImage'] == true;
    final isToggled = data['isToggled'] == true || data['isChecked'] == true;
    final isTextField = data['isTextField'] == true;
    final isSlider = data['isSlider'] == true;
    final isHeader = data['isHeader'] == true;
    final hasTap = data['hasTap'] == true || data['hasLongPress'] == true;
    final hasIncreaseDecrease =
        data['hasIncrease'] == true || data['hasDecrease'] == true;
    final mergesDescendants = data['mergesDescendants'] == true;

    // Determine role - use widget name override for known edge cases
    final role = _determineRole(
      widgetName: name,
      isButton: isButton,
      isImage: isImage,
      isToggled: isToggled,
      isTextField: isTextField,
      isSlider: isSlider,
      isHeader: isHeader,
    );

    // Determine properties - include increase/decrease actions as interactive
    final isInteractive =
        hasTap || hasIncreaseDecrease || _isKnownInteractive(name);
    final mergesChildren = mergesDescendants || _shouldMergeChildren(name);
    final semanticsManaged = _isSemanticsManaged(name);
    final hasTooltipParam = _hasTooltipParam(name);
    final hasSemanticLabelParam = _hasSemanticLabelParam(name);

    // Write entry
    buffer.writeln("    '$name': WidgetSemanticsInfo(");
    buffer.writeln('      role: $role,');
    buffer.writeln('      isInteractive: $isInteractive,');
    buffer.writeln('      mergesChildren: $mergesChildren,');
    buffer.writeln('      semanticsManaged: $semanticsManaged,');
    buffer.writeln('      hasTooltipParam: $hasTooltipParam,');
    buffer.writeln('      hasSemanticLabelParam: $hasSemanticLabelParam,');
    buffer.writeln('    ),');
  });

  buffer
    ..writeln('  };')
    ..writeln()
    ..writeln('  /// Lookup semantics info for a widget by name')
    ..writeln('  static WidgetSemanticsInfo? lookup(String? widgetName) {')
    ..writeln('    if (widgetName == null) return null;')
    ..writeln('    return widgets[widgetName];')
    ..writeln('  }')
    ..writeln('}');

  // Write to file
  await outFile.writeAsString(buffer.toString());

  // ignore: avoid_print
  print('✓ Generated ${outFile.path}');
  // ignore: avoid_print
  print('✓ ${json.length} widgets mapped');
}

String _determineRole({
  required String widgetName,
  required bool isButton,
  required bool isImage,
  required bool isToggled,
  required bool isTextField,
  required bool isSlider,
  required bool isHeader,
}) {
  // Widget name-based overrides for known edge cases where runtime extraction
  // doesn't accurately reflect the widget's semantic role.
  // These are based on Flutter documentation and actual widget behavior.
  const roleOverrides = {
    // TextField often doesn't expose isTextField flag in simple configurations
    'TextField': 'SemanticRole.input',
    'TextFormField': 'SemanticRole.input',
    // Radio widgets expose isChecked but should map to toggle role
    'Radio': 'SemanticRole.toggle',
    'RadioListTile': 'SemanticRole.toggle',
    // ListTile family are semantically list items
    'ListTile': 'SemanticRole.listItem',
  };

  if (roleOverrides.containsKey(widgetName)) {
    return roleOverrides[widgetName]!;
  }

  // Flag-based role determination from runtime semantics
  if (isButton) return 'SemanticRole.button';
  if (isImage) return 'SemanticRole.image';
  if (isToggled) return 'SemanticRole.toggle';
  if (isTextField) return 'SemanticRole.input';
  if (isSlider) return 'SemanticRole.slider';
  if (isHeader) return 'SemanticRole.header';
  return 'SemanticRole.group';
}

bool _isKnownInteractive(String widgetName) {
  // Widgets known to be interactive even if runtime extraction doesn't show it.
  // This handles complex widgets where interactivity isn't exposed in simple configs.
  const interactiveWidgets = {
    'TextField',
    'TextFormField',
    'Slider',
    'Radio',
    'RadioListTile',
  };
  return interactiveWidgets.contains(widgetName);
}

bool _shouldMergeChildren(String widgetName) {
  // Widgets that merge children semantics into a single node.
  // Based on Flutter's semantic behavior and documentation.
  const mergingWidgets = {
    'ListTile',
    'CheckboxListTile',
    'SwitchListTile',
    'RadioListTile',
    'Card',
  };
  return mergingWidgets.contains(widgetName);
}

bool _isSemanticsManaged(String widgetName) {
  // Widgets that fully manage their own semantics
  const managedWidgets = {
    'IconButton',
    'ElevatedButton',
    'TextButton',
    'OutlinedButton',
    'FilledButton',
    'FloatingActionButton',
    'Switch',
    'Checkbox',
    'Radio',
    'Slider',
    'TextField',
    'TextFormField',
    'ListTile',
    'CheckboxListTile',
    'SwitchListTile',
    'RadioListTile',
    'Semantics',
    'MergeSemantics',
    'ExcludeSemantics',
    'BlockSemantics',
  };
  return managedWidgets.contains(widgetName);
}

bool _hasTooltipParam(String widgetName) {
  // Widgets with tooltip parameter
  const tooltipWidgets = {
    'IconButton',
    'FloatingActionButton',
  };
  return tooltipWidgets.contains(widgetName);
}

bool _hasSemanticLabelParam(String widgetName) {
  // Widgets with semanticLabel parameter
  const semanticLabelWidgets = {
    'Image',
    'CircleAvatar',
  };
  return semanticLabelWidgets.contains(widgetName);
}
